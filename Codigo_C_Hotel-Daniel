#define CLIENTES_FILE "clientes.dat"
#define FUNC_FILE "funcionarios.dat"
#define QUARTOS_FILE "quartos.dat"
#define ESTADIAS_FILE "estadias.dat"

typedef struct {
    int codigo;
    char nome[100];
    char endereco[150];
    char telefone[20];
} Cliente;

typedef struct {
    int codigo;
    char nome[100];
    char telefone[20];
    char cargo[30];
    double salario;
} Funcionario;

typedef struct {
    int numero;
    int qtd_hospedes;
    double valor_diaria;
    char status[10];
} Quarto;

typedef struct {
    int codigo;
    int cliente_codigo;
    int quarto_numero;
    int data_entrada;
    int data_saida;
    int qtd_diarias;
    int ativo;
} Estadia;

void cadastrar_cliente() {
    Cliente c;
    printf("Digite codigo (0 para gerar automatico): ");
    if(scanf("%d", &c.codigo) != 1) { while(getchar()!='\n'); printf("Entrada invalida.\n"); return; }
    getchar();
    if(c.codigo == 0) {
        FILE *f = fopen(CLIENTES_FILE, "rb");
        int max = 0;
        if(f) {
            Cliente tmp;
            while(fread(&tmp, sizeof(tmp), 1, f)) if(tmp.codigo > max) max = tmp.codigo;
            fclose(f);
        }
        c.codigo = max + 1;
    } else {
        if(existe_cliente(c.codigo, NULL)) {
            printf("Codigo ja existe. Operacao cancelada.\n");
            return;
        }
    }
    printf("Nome: ");
    fgets(c.nome, sizeof(c.nome), stdin);
    c.nome[strcspn(c.nome, "\n")] = 0;
    printf("Endereco: ");
    fgets(c.endereco, sizeof(c.endereco), stdin);
    c.endereco[strcspn(c.endereco, "\n")] = 0;
    printf("Telefone: ");
    fgets(c.telefone, sizeof(c.telefone), stdin);
    c.telefone[strcspn(c.telefone, "\n")] = 0;

    FILE *f = fopen(CLIENTES_FILE, "ab");
    if(!f) { perror("Erro ao abrir arquivo"); return; }
    fwrite(&c, sizeof(c), 1, f);
    fclose(f);
    printf("Cliente cadastrado com codigo %d\n", c.codigo);
}

if(c.codigo == 0) {
    FILE *f = fopen(CLIENTES_FILE, "rb");
    int max = 0;
    if(f) {
        Cliente tmp;
        while(fread(&tmp, sizeof(tmp), 1, f)) if(tmp.codigo > max) max = tmp.codigo;
        fclose(f);
    }
    c.codigo = max + 1;
}

if(scanf("%d", &c.codigo) != 1) { 
    while(getchar()!='\n'); 
    printf("Entrada invalida.\n"); 
    return; 
}

if(existe_cliente(c.codigo, NULL)) {
    printf("Codigo ja existe. Operacao cancelada.\n");
    return;
}

char *case_insensitive_search(const char *haystack, const char *needle) {
    if (!*needle) return (char *)haystack;
    size_t needle_len = strlen(needle);
    for (; *haystack; haystack++) {
        size_t i;
        for (i = 0; i < needle_len; ++i) {
            if (!haystack[i]) break;
            if (tolower((unsigned char)haystack[i]) != tolower((unsigned char)needle[i])) break;
        }
        if (i == needle_len) return (char *)haystack;
    }
    return NULL;
}

void cadastrar_estadia() {
    Estadia e;
    
    printf("Digite codigo do cliente: ");
    if(scanf("%d", &e.cliente_codigo) != 1) { while(getchar()!='\n'); printf("Entrada invalida.\n"); return; }
    getchar();
    Cliente ctmp;
    if(!existe_cliente(e.cliente_codigo, &ctmp)) {
        printf("Cliente nao cadastrado.\n");
        return;
    }
    
    int qtd_hospedes;
    printf("Quantidade de hospedes: ");
    if(scanf("%d", &qtd_hospedes) != 1) { while(getchar()!='\n'); printf("Entrada invalida.\n"); return; }
    getchar();
    printf("Data de entrada (YYYYMMDD): ");
    if(scanf("%d", &e.data_entrada) != 1) { while(getchar()!='\n'); printf("Entrada invalida.\n"); return; }
    getchar();
    printf("Data de saida (YYYYMMDD): ");
    if(scanf("%d", &e.data_saida) != 1) { while(getchar()!='\n'); printf("Entrada invalida.\n"); return; }
    getchar();
    
    if(e.data_saida <= e.data_entrada) {
        printf("Data de saida deve ser posterior a data de entrada.\n");
        return;
    }
    
    Quarto qfound;
    if(!encontrar_quarto_disponivel(qtd_hospedes, e.data_entrada, e.data_saida, &qfound)) {
        printf("Nenhum quarto disponivel para o periodo e quantidade de hospedes.\n");
        return;
    }
    
    FILE *f = fopen(ESTADIAS_FILE, "rb");
    int max = 0;
    if(f) {
        Estadia tmp;
        while(fread(&tmp, sizeof(tmp), 1, f)) if(tmp.codigo > max) max = tmp.codigo;
        fclose(f);
    }
    e.codigo = max + 1;
    e.quarto_numero = qfound.numero;
    
    e.qtd_diarias = diff_days(e.data_entrada, e.data_saida);
    if(e.qtd_diarias <= 0) {
        printf("Erro no calculo de diarias.\n");
        return;
    }
    e.ativo = 1;

    FILE *fw = fopen(ESTADIAS_FILE, "ab");
    if(!fw) { perror("Erro ao abrir estadias"); return; }
    fwrite(&e, sizeof(e), 1, fw);
    fclose(fw);

    atualizar_status_quarto(e.quarto_numero, "ocupado");
    printf("Estadia cadastrada codigo %d no quarto %d por %d diarias.\n", e.codigo, e.quarto_numero, e.qtd_diarias);
}

int encontrar_quarto_disponivel(int qtd_hospedes, int entrada, int saida, Quarto *out) {
    FILE *f = fopen(QUARTOS_FILE, "rb");
    if(!f) return 0;
    Quarto q;
    while(fread(&q, sizeof(q), 1, f)) {
        if(strcmp(q.status, "desocupado") == 0 && q.qtd_hospedes >= qtd_hospedes) {
            if(quarto_disponivel_para_periodo(q.numero, entrada, saida)) {
                if(out) *out = q;
                fclose(f);
                return 1;
            }
        }
    }
    fclose(f);
    return 0;
}

int quarto_disponivel_para_periodo(int numero, int entrada, int saida) {
    FILE *f = fopen(ESTADIAS_FILE, "rb");
    if(!f) return 1;
    Estadia e;
    while(fread(&e, sizeof(e), 1, f)) {
        if(e.quarto_numero == numero && e.ativo) {
            if(periodo_sobrepoe(e.data_entrada, e.data_saida, entrada, saida)) {
                fclose(f);
                return 0;
            }
        }
    }
    fclose(f);
    return 1;
}

int periodo_sobrepoe(int e1_in, int e1_out, int e2_in, int e2_out) {
    return (e1_in < e2_out) && (e2_in < e1_out);
}

int diff_days(int d1, int d2) {
    int days1 = ymd_to_time_days(d1);
    int days2 = ymd_to_time_days(d2);
    return days2 - days1;
}

int ymd_to_time_days(int yyyymmdd) {
    int y = yyyymmdd / 10000;
    int m = (yyyymmdd / 100) % 100;
    int d = yyyymmdd % 100;
    struct tm t = {0};
    t.tm_year = y - 1900;
    t.tm_mon = m - 1;
    t.tm_mday = d;
    t.tm_hour = 12;
    time_t tt = mktime(&t);
    if (tt == (time_t)-1) return 0;
    return (int)(tt / 86400);
}
